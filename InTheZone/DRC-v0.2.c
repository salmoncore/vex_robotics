#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    MGPotentR,      sensorNone)
#pragma config(Sensor, in2,    MGPotentL,      sensorNone)
#pragma config(Sensor, in3,    LiftPotentR,    sensorNone)
#pragma config(Sensor, in4,    LiftPotentL,    sensorNone)
#pragma config(Sensor, in5,    ArmPotentR,     sensorNone)
#pragma config(Sensor, in6,    ArmPotentL,     sensorNone)
#pragma config(Sensor, in8,    gyro,           sensorNone)
#pragma config(Sensor, dgtl2,  encoderPlaceholder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ultPlaceholder, sensorSONAR_inch)
#pragma config(Sensor, dgtl8,  jumperPlaceholder, sensorTouch)
#pragma config(Motor,  port1,           motorLeft,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mgLeft,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mgRight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motorRight,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Make sure to go to Window>Menu>Super User to view every option in the Motor and Sensor Setup

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "lcdLib.c"

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// Start of functions

void LiftUp()
{
	motor[liftRight] = 127;
	motor[liftLeft] = 127;
}

void LiftDown()
{
	motor[liftRight] = -127;
	motor[liftLeft] = -127;
}

void LiftHold()
{
	motor[liftRight] = 25;
	motor[liftLeft] = 25;
}

void LiftStop()
{
	motor[liftRight] = 0;
	motor[liftLeft] = 0;
}

void LiftPositionUp()
{
	while(SensorValue[LiftPotentR] < 300 && SensorValue[LiftPotentL] < 300)
	{
		LiftUp();
	}
	LiftStop();
}

void DriveForward()
{
	motor[motorRight] = 127;
	motor[motorLeft] = 127;
}

void DriveStop()
{
	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}

void TurnPointLeft()
{
	motor[motorLeft] = -127;
	motor[motorRight] = 127;
}

void TurnPointRight()
{
	motor[motorLeft] = 127;
	motor[motorRight] = -127;
}

void TurnSwingRight()
{
	motor[motorLeft] = 127;
	motor[motorRight] = 0;
}

void TurnSwingLeft()
{
	motor[motorLeft] = 0;
	motor[motorRight] = 127;
}

void MGUp()
{
	motor[mgRight] = 127;
	motor[mgLeft] = 127;
}

void MGDown()
{
	motor[mgRight] = -127;
	motor[mgLeft] = -127;
}

void MGStop()
{
	motor[mgRight] = 0;
	motor[mgLeft] = 0;
}

void ArmUp()
{
	motor[armRight] = 127;
	motor[armLeft] = 127;
}

void ArmDown()
{
	motor[armRight] = -127;
	motor[armLeft] = -127;
}

void ArmStop()
{
	motor[armRight] = 0;
	motor[armLeft] = 0;
}

void ClawOpen()
{
	motor[clawMotor] = 127;
}

void ClawClose()
{
	motor[clawMotor] = -127;
}

void ClawStop()
{
	motor[clawMotor] = 0;
}

void MGAlign()
{
	while(abs((SensorValue[MGPotentL]) - (SensorValue[MGPotentR])) > 30)
	{
		if(abs(SensorValue[MGPotentL]) > abs(SensorValue[MGPotentR]))
		{
			motor[mgRight] = 25;
			motor[mgLeft] = -25;
		}
		else if(abs(SensorValue[MGPotentL]) < abs(SensorValue[MGPotentR]))
		{
			motor[mgLeft] = 25;
			motor[mgLeft] = -25;
		}
	}
	MGStop();
}

void LiftAlign()
{
	while(abs((SensorValue[LiftPotentL]) - (SensorValue[LiftPotentR])) > 30)
	{
		if(abs(SensorValue[LiftPotentL]) > abs(SensorValue[LiftPotentR]))
		{
			motor[mgRight] = 25;
			motor[mgLeft] = -25;
		}
		else if(abs(SensorValue[LiftPotentL]) < abs(SensorValue[LiftPotentR]))
		{
			motor[mgLeft] = 25;
			motor[mgLeft] = -25;
		}
	}
	LiftStop();
}

void ArmAlign()
{
	while(abs((SensorValue[ArmPotentL]) - (SensorValue[ArmPotentR])) > 30)
	{
		if(abs(SensorValue[ArmPotentL]) > abs(SensorValue[ArmPotentR]))
		{
			motor[mgRight] = 25;
			motor[mgLeft] = -25;
		}
		else if(abs(SensorValue[ArmPotentL]) < abs(SensorValue[ArmPotentR]))
		{
			motor[mgLeft] = 25;
			motor[mgLeft] = -25;
		}
	}
	ArmStop();
}

// Start of Tasks

task BatteryLCD() //Aka the second LDC Screen
{
	// Initalizes the second LCD on UART1
	vexLcdInit(UART1);
	// Backlight Control
	vexLcdBacklight(1);

	string VoltLn1;
	string VoltLn2;

	while(true)
	{

		sprintf(VoltLn1, "MBa %1.1f EBa %1.1f", nAvgBatteryLevel/1000, (SensorValue[in5]*(5.48/184.7)/10));
		sprintf(VoltLn2, "BBa %1.1f", BackupBatteryLevel/1000);

		vexLcdSet(0, VoltLn1);
		vexLcdSet(1, VoltLn2);

	}
}


task DriveControl()
{

while(true)
{
	motor[motorRight] = vexRT[Ch3] - vexRT[Ch1];
	motor[motorLeft] = vexRT[Ch3] + vexRT[Ch1];
}

}

task LiftControl()
{

while(true)
{
	if(vexRT[Btn6U] == 1)
	{
		LiftUp();
	}

	else if(vexRT[Btn6D] == 1)
	{
		LiftDown();
	}

	else
	{
		LiftHold();
	}
}

}

task ClawControl()
{

while(true)
{
	if(vexRT[Btn8D] == 1)
	{
		ClawOpen();
	}

	else if(vexRT[Btn8R] == 1)
	{
		ClawClose();
	}

	else
	{
		ClawStop();
	}
}

}

task ArmControl()
{

while(true)
{
	if(vexRT[Btn5U] == 1)
	{
		ArmUp();
	}

	else if(vexRT[Btn5D] == 1)
	{
		ArmDown();
	}

	else
	{
		ArmStop();
	}
}

}

task MGControl()
{

while(true)
{
	if(vexRT[Btn7U] == 1)
	{
		MGUp();
	}

	else if(vexRT[Btn7D] == 1)
	{
		MGDown();
	}

	else
	{
		MGStop();
	}
}

}

void sensorInit() // The function for initalizing the gyroscope, includes all the waits and etc.
{
	//Gyroscope in analog port 1
	SensorType[gyro] = sensorNone;
	wait1Msec(250);
	SensorType[gyro] = sensorGyro;
	wait1Msec(2550);
	playTone(440,25);
}

// This is where the LCD Screen code is located.

int autonSelect = 1; //Default Autonomous

void pre_auton() // LCD Screen Code
{
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	int countMin = 0;
	int countMax = 6;
	int counter = countMin;
	string str[7] = {"Pgrm1","Pgrm2","Pgrm3","Pgrm4","Pgrm5","Pgrm6","Pgrm7"}; //Program Names
	bLCDBacklight = true;
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	startTask(BatteryLCD);

	while(bIfiRobotDisabled == true)
	{

		if(nLCDButtons == 1)
		{
			if(counter == countMin)
			{
				counter = countMax;
			}

			else
			{
				counter--;
			}

			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else if(nLCDButtons == 4)
		{
			if(counter == countMax)
			{
				counter = countMin;
			}

			else
			{
				counter++;
			}

			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else if(nLCDButtons == 2)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			if(counter != countMin) autonSelect = counter;

			else sensorInit();

			wait1Msec(250);
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"Selected!");
			wait1Msec(400);
			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else
		{
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"<    Select    >");
		}

	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Tasks                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task autonomous()
{

	startTask(BatteryLCD);

	switch(autonSelect)
	{

	case 1: //Program Option 1

		wait1Msec(true);

		break;

	case 2: //Program Option 2

		wait1Msec(true);

		break;

	case 3: //Program Option 3

		wait1Msec(true);

		break;

	case 4: //Program Option 4

		wait1Msec(true);

		break;

	case 5: //Program Option 5

		wait1Msec(true);

		break;

	case 6: //Program Option 6

		wait1Msec(true);

		break;

	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop

		startTask(DriveControl);
		startTask(ClawControl);
		startTask(LiftControl);
		startTask(MGControl);
		startTask(ArmControl);
		startTask(BatteryLCD);

}
