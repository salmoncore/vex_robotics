#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    potentArm,      sensorPotentiometer)
#pragma config(Sensor, in2,    potentClaw,     sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in5,    expanderVoltage, sensorAnalog)
#pragma config(Sensor, dgtl2,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  Jumper2,        sensorTouch)
#pragma config(Sensor, dgtl5,  ultFront,       sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  Jumper3,        sensorTouch)
#pragma config(Sensor, dgtl11, encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, I2C_2,  encoderRight,   sensorNone)
#pragma config(Motor,  port1,           motorBackLeft, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           motorFrontLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motorClawRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           motorClawLeft, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armInnerLeft,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           armYLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armYRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armInnerRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           motorFrontRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          motorBackRight, tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Okay Zach/Halan, here's a quick runthrough of how this program is structured:

// -Pragma Statements (Do not edit manually, just use the Motor and Sensor Setup)
// -Some VEX Competition Stuff (Don't mess with that either)
// -PreAuton
// --Variables (Templates for arm and claw positions used in the PID loop are stored here)
// --Functions (Used to complete the movements in autonomous)
// --PID Loops (Should be working, just don't mess with tuning unless you know what's going on)
// --Assortment of controls for the PID loop and etc. (It's a bit messy)
// --Tasks (Includes startable and stopable functionality for the lift, claw, drive, and speaker)
// --LCD Screen Code (Includes the functionality for program switching, etc. You can also change the default auton from here)
// -Autonomous
// --Fence Left (Grabs cube, throws it over, grabs stars, throws them over)
// --Fence Right (Grabs cube, throws it over, grabs stars, throws them over)
// --Skills
// --Backup (Does the simple one point auton)
// -Driver Control (Starts the controls for the claw, arm, and drive when the match starts)

// Most of the troubleshooting you would be doing would probably take place down in the Autonomous section.
// So for the times where the drive doesn't go far enough, or it turns too much, those would be handled by the wheel encoders.
// Simply change the values in the 'If' statements to the value you're looking for.
// Some things to note:
// This is the function for going forward using the encoders;

//while(SensorValue[encoderLeft] > -325 && SensorValue[encoderRight] > -325) //Lines up with cube.
//		{
//			DriveForward();
//		}
//		DriveStop();

// The distance is determined by the 'SensorValue' part in the '()', where it says '-325'
// Because of how the encoders are mounted, you'll want to count backwards for a forward movement, and vice-versa.
// Use logic for troubleshooting distances. If the base goes too far, you'll want to decrease the negative value. (-325 --> -275)

// We're doing a similar sort of thing for turns. This is how to properly make a ~90 degree turn to the right:

//while(abs(SensorValue[encoderLeft]) < 280 && abs(SensorValue[encoderRight]) < 280)
//		{
//			TurnPointRight();
//		}

// This time, the 'SensorValue' is put inside a 'abs' function, which converts the encoder value to an absolute value.
// 'abs' also saves some time, you can do 'TurnPointRight()' or 'TurnPointLeft()' and you don't have to make the 280 a negative.
// In other words, it turns to the value you're looking for, no matter if it's turning left or right.
// Anyway, it turns until it reaches a value above 280, which is close to a right turn (In our testing).
// If this value is wrong and it turns too much or little, first check battery and make sure the encoders reset in the code.
// The drive encoder reset looks like this:

//SensorValue[encoderLeft] = 0;
//SensorValue[encoderRight] = 0;

// If it's still wrong, simply increase or decrease the value for the turn. (280 --> 300)
// Just don't make it negative, that'll probably make it spin around in a circle forever.

// Now, if the arm or claw is the thing that messes up, it's pretty easy to fix.
// Scroll down from here just a tiny bit, right below the PreAuton header.
// See all those integer values? That's what you need to change.

// In order to test to fix the value for the arm or claw, download the program via the programming module.
// Press 'Start' on the window that pops up in RobotC, and make sure the control switch is set to driver.
// Move the arm/claw to the value you desire for it to go to, and make note of the potentiometer value in RobotC.
// Remember, the potentiometer name is what was determined in the Motor and Sensor Setup.
// From there, scroll down back to where you found all those integer values, and modify the appropriate one.
// This may take some messing around, so be paitent.
// However, several times in the code, we did stuff like this:

//ClawTarget = ClawFlat;
//		while(SensorValue(potentClaw) < ClawTarget-400)
//		{
//			ClawClose();
//		}
//		ClawStop();

// See how on the second line of that, we subtracted 400 from the value we're looking for?
// That's because we were too lazy to make an int for every single specific movement, I guess.
// Either way, this is to move the claw out just enough to pop the rubber bands off.
// As you may have deduced, it's about 400 degrees less then the int value ClawFlat.
// So if it's something like this messing up, you might just have to modify the subtracted value.
// And if you modify something like ClawFlat, you might have to add/subtract more for the rubber bands to pop off.
// That all sounds pretty complex, but in all honesty it's just some tesing at the worst.

// Anyway, that's a quick runthrough of how to modify the autonomous.
// If you have any questions, send me a text and I'll try and get back to you.

// Good luck my dudes.

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "lcdLib.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

int SoundIndicate = 0;

int LiftIndicate = 0;
int ClawIndicate = 0;

// These are the values you'd want to change if the claw/arm was messing up.

const int ClawFlat = 1743;
const int ClawBack = 3350;
const int ClawPartial = 2600;
const int ForceClawClose = 3670;

const int LiftFullDown = 1080;
const int LiftHold = 2800;
const int LiftThrowBegin = 2000;
const int LiftThrowRelease = 2800;
const int LiftThrowComplete = 3000;

// Start of functions.

void ArmUp()
{
	motor[armYRight] = 127;
	motor[armYLeft] = 127;
	motor[armInnerRight] = 127;
	motor[armInnerLeft] = 127;
}

void ArmStop()
{
	motor[armYRight] = 0;
	motor[armYLeft] = 0;
	motor[armInnerRight] = 0;
	motor[armInnerLeft] = 0;
}

void ArmDown()
{
	motor[armYRight] = -127;
	motor[armYLeft] = -127;
	motor[armInnerRight] = -127;
	motor[armInnerLeft] = -127;
}

void DriveForward()
{
	motor[motorBackLeft] = 127;
	motor[motorBackRight] = 100;
	motor[motorFrontLeft] = 100;
	motor[motorFrontRight] = 100;
}

void DriveForwardSlow()
{
	motor[motorBackLeft] = 127/2;
	motor[motorBackRight] = 100/2;
	motor[motorFrontLeft] = 100/2;
	motor[motorFrontRight] = 100/2;
}

void DriveBackwards()
{
	motor[motorBackLeft] = -127;
	motor[motorBackRight] = -127;
	motor[motorFrontLeft] = -127;
	motor[motorFrontRight] = -127;
}

void DriveBackwardsSlow()
{
	motor[motorBackLeft] = -127/2;
	motor[motorBackRight] = -100/2;
	motor[motorFrontLeft] = -100/2;
	motor[motorFrontRight] = -100/2;
}

void TurnPointLeft()
{
	motor[motorBackLeft] = -127/1.25;
	motor[motorBackRight] = 127/1.25;
	motor[motorFrontLeft] = -127/1.25;
	motor[motorFrontRight] = 127/1.25;
}

void TurnPointRight()
{
	motor[motorBackLeft] = 127/1.25;
	motor[motorBackRight] = -127/1.25;
	motor[motorFrontLeft] = 127/1.25;
	motor[motorFrontRight] = -127/1.25;
}

void TurnSwingRight()
{
	motor[motorBackLeft] = 127/1.25;
	motor[motorBackRight] = 0;
	motor[motorFrontLeft] = 127/1.25;
	motor[motorFrontRight] = 0;
}

void TurnSwingLeft()
{
	motor[motorBackLeft] = 0;
	motor[motorBackRight] = 127/1.25;
	motor[motorFrontLeft] = 0;
	motor[motorFrontRight] = 127/1.25;
}

void DriveStop()
{
	motor[motorBackLeft] = 0;
	motor[motorBackRight] = 0;
	motor[motorFrontLeft] = 0;
	motor[motorFrontRight] = 0;
}

void ClawOpen()
{
	motor[motorClawRight] = -127;
	motor[motorClawLeft] = -127;
}

void ClawStop()
{
	motor[motorClawRight] = 0;
	motor[motorClawLeft] = 0;
}

void ClawClose()
{
	motor[motorClawRight] = 127;
	motor[motorClawLeft] = 127;
}

// Start of PID Programming.

//Constants for P and D calculations
float kP = 0.65;
float kD = 0.55;

//Store lastError as a global variable
int lastError = 0;

//PD function
int pdControl(int target)
{
	//Calculate standard PID error
	int error = target-SensorValue[gyro];//Place the correct sensor to be used

	//Calculate the P value
	float pResult = error*kP;

	//Declare the derivative variable
	int derivative;

	//Do not calculate the derivtive if there is no last error
	if(lastError != 0)
	{
		derivative = error-lastError;
	}
	else
	{
		derivative = 0;
	}

	//Calculate the D value
	float dResult = derivative*kD;

	//Determine the final result of the PD calculation
	float result = pResult+dResult;

	//Store the current error for the next PD calculation
	lastError = error;

	//Send result to the motors, with the correct directions
	//Might require
	motor[motorBackLeft] = -1 * result;
	motor[motorBackRight] = result;
	motor[motorFrontLeft] = -1 * result;
	motor[motorFrontRight] = result;

	//Wait before the next calculation
	wait1Msec(25);

	//Return the amount of error from the current calculation
	return error;
}

//Constants for P and D calculations
float ClawkP = 0.68;
float ClawkD = 0.52;

//Store lastError as a global variable
int ClawlastError = 0;

int LiftError;
int ClawError;
int ClawTarget;

//PD function
int ClawpdControl(int target)
{
	//Calculate standard PID error
	int error = target-SensorValue[potentClaw];//Place the correct sensor to be used

	//Calculate the P value
	float pResult = error*ClawkP;

	//Declare the derivative variable
	int derivative;

	//Do not calculate the derivtive if there is no last error
	if(ClawlastError != 0)
	{
		derivative = error-ClawlastError;
	}
	else
	{
		derivative = 0;
	}

	//Calculate the D value
	float dResult = derivative*ClawkD;

	//Determine the final result of the PD calculation
	float result = pResult+dResult;


	//Store the current error for the next PD calculation
	ClawlastError = error;

	//Send result to the motors, with the correct directions
	//Might require

	if(ClawIndicate == 1)
	{
		motor[motorClawLeft] = result;
		motor[motorClawRight] = result;
	}

	//Wait before the next calculation
	wait1Msec(25);

	//Return the amount of error from the current calculation
	return error;
}

task ClawPD()
{
	while(true)
	{

		if(vexRT[Btn8L] == 1)
		{
			ClawTarget = LiftFullDown;
			ClawIndicate = 1;
		}

		else if(vexRT[Btn8D] == 1)
		{
			ClawStop();
			ClawIndicate = 1;

			while(abs(LiftThrowRelease - SensorValue[potentArm]) > 450)
			{

			}
			ClawTarget = ClawFlat;
		}

		else if(vexRt[Btn5D] == 1)
		{
			ClawClose();
			ClawIndicate = 0;
		}

		else if(vexRT[Btn5U] == 1)
		{
			ClawOpen();
			ClawIndicate = 0;
		}

		else if(ClawIndicate == 0 && (vexRT[Btn5D] == 0 && vexRT[Btn5U] == 0))
		{
			ClawStop();
		}

		ClawError = abs(ClawpdControl(ClawTarget));
	}
}

//Constants for P and D calculations
float LiftkP = 0.70;
float LiftkD = 0.60; //Was 52

//Store lastError as a global variable
int LiftlastError = 0;


int LiftTarget;

//PD function
int LiftpdControl(int target)
{
	//Calculate standard PID error
	int error = target-SensorValue[potentArm];//Place the correct sensor to be used

	//Calculate the P value
	float pResult = error*LiftkP;

	//Declare the derivative variable
	int derivative;

	//Determine the final result of the PD calculation
	float result = pResult;

	//Store the current error for the next PD calculation
	LiftlastError = error;

	if(LiftIndicate == 1)
	{


		//Send result to the motors, with the correct directions
		//Might require
		motor[armYRight] = result;
		motor[armYLeft] = result;
		motor[armInnerRight] = result;
		motor[armInnerLeft] = result;
	}
	//Wait before the next calculation
	wait1Msec(25);

	//Return the amount of error from the current calculation
	return error;
}

// Start of Tasks.

task LiftPD()
{
	while(true)
	{

		if(vexRT[Btn8R] == 1)
		{
			while(SensorValue[potentArm] > LiftFullDown)
			{
				ArmDown();
			}
		}

		else if(vexRT[Btn8D] == 1)
		{
			while(SensorValue[potentArm] < LiftThrowRelease)
			{
				ArmUp();
			}
		}

		else if(vexRt[Btn6D] == 1)
		{
			ArmDown();
			LiftIndicate = 0;
		}

		else if(vexRT[Btn6U] == 1)
		{
			ArmUp();
			LiftIndicate = 0;
		}

		else if((vexRT[Btn6D] == 0 && vexRT[Btn6U] == 0))
		{
			ArmStop();
		}

		//LiftError = abs(LiftpdControl(LiftTarget));
	}
}

task ManualArmControl() // Arm Control
{
	while(true)
	{
		if(vexRT[Btn6U] == 1)
		{
			ArmUp();
		}

		else if(vexRT[Btn6D] == 1)
		{
			ArmDown();
		}

		else
		{
			ArmStop();
		}
	}
}

task ManualClawControl() // Claw Control
{
	while(true)
	{
		if(vexRT[Btn5U] == 1)
		{
			ClawOpen();
		}
		else if(vexRT[Btn5D] == 1)
		{
			ClawClose();
		}
		else
		{
			ClawStop();
		}

	}
}

task BatteryLCD()
{
	// Init the second LCD on uart 1
	vexLcdInit(UART1);
	// backlight on
	vexLcdBacklight(1);

	string VoltLn1;
	string VoltLn2;

	while(true)
	{

		sprintf(VoltLn1, "MBa %1.1f EBa %1.1f", nAvgBatteryLevel/1000, (SensorValue[in5]*(5.48/184.7)/10);
		sprintf(VoltLn2, "BBa %1.1f", BackupBatteryLevel/1000);

		vexLcdSet(0, VoltLn1);
		vexLcdSet(1, VoltLn2);

	}
}

task LiftandClawControl(){
	startTask(LiftPD);
	startTask(ClawPD);
	while(1==1){
		//Emergency PD exit
		if(vexRT[Btn6D] == 1 && vexRT[Btn6U] == 1){
			wait1Msec(500);
			if(vexRT[Btn6D] == 1 && vexRT[Btn6U] == 1){
				SoundIndicate = 1;
				stopTask(LiftPD);
				stopTask(ClawPD);
				startTask(ManualArmControl);
				startTask(ManualClawControl);
				return;
			}
		}
		else{
			//Throw and other subroutines with claw and arm
			if(vexRT[Btn8U] == 1){
				LiftTarget = LiftThrowBegin;
				ClawTarget = ForceClawClose;

				while(LiftError > 10){
				}

				stopTask(ClawPD);
				ClawStop();
				LiftTarget = LiftThrowRelease;

				while(LiftError > 30){
				}

				ClawTarget = ClawFlat;
				startTask(ClawPD);

				LiftTarget = LiftThrowComplete;

				while(LiftError > 10){
				}
			}
			else{
				//Individual, seperated PD control for claw and arm
				if(vexRT[Btn7D] == 1){
					LiftTarget = LiftFullDown;
					ClawTarget = ClawFlat;
				}
				else if(vexRT[Btn7U] == 1){
					LiftTarget = LiftHold;
				}
				//else if(vexRT[Btn6U] == 1){
				//	stopTask(LiftPD);
				//	ArmUp();
				//}
				//else if(vexRT[Btn6D] == 1){
				//	stopTask(LiftPD);
				//	ArmDown();
				//}
				//else{
				//	LiftTarget = SensorValue[potentArm];
				//	startTask(LiftPD);
				//}

				if(vexRT[Btn8D] == 1){
					ClawTarget = ClawFlat;
				}
				else if(vexRT[Btn8R] == 1){
					ClawTarget = ClawBack;
				}
				//else if(vexRT[Btn5U] == 1){
				//	stopTask(ClawPD);
				//	ClawClose();
				//}
				//else if(vexRT[Btn5D] == 1){
				//	stopTask(ClawPD);
				//	ClawOpen();
				//}
				//else{
				//	ClawTarget = SensorValue[potentClaw];
				//	startTask(ClawPD);
				//}

			}
		}
		EndTimeSlice();
	}
}

task DriveControl() // Drive Control
{
	while(true)
	{
		motor[motorFrontRight] = vexRT[Ch3] - vexRT[Ch1];
		motor[motorBackRight] =  vexRT[Ch3] - vexRT[Ch1];
		motor[motorFrontLeft] = vexRT[Ch3] + vexRT[Ch1];
		motor[motorBackLeft] =  vexRT[Ch3] + vexRT[Ch1];
	}
}

/////ZACH DID THIS///////
//task SoundControl()    //
//{                      //
//while(1==1)            //
//	if (vexRT[Btn7L]==1) //
//		//CODE             //
//}                      //
///////ZACH DID THIS///////

task SoundControl(){
	while(1 == 1){
		/*if(vexRT[Ch3] < -30){
		SoundIndicate = 2;
		}*/
		switch(SoundIndicate){
		case 1:
			SoundIndicate = 0;
			break;
		case 2:
			SoundIndicate = 0;
			break;
		case 3:
			SoundIndicate = 0;
			break;
		case 4:
			SoundIndicate = 0;
			break;
		}
		EndTimeSlice();
	}
}

void sensorInit() // The function for initalizing the gyroscope, includes all the waits and etc.
{
	//Gyroscope in analog port 1
	SensorType[gyro] = sensorNone;
	wait1Msec(250);
	SensorType[gyro] = sensorGyro;
	wait1Msec(2550);
	playTone(440,25);
}

// This is where the LCD Screen code is located.

int autonSelect = 4; //Default Autonomous

void pre_auton() // LCD Screen Code
{
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	int countMin = 0;
	int countMax = 6;
	int counter = countMin;
	string str[7] = {"SensorInit", "FenceLeft", "FenceRight","ProgSkills","Backup","CloseLeft","CloseRight"};
	bLCDBacklight = true;
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	//SensorType[in1] = sensorPotentiometer;

	startTask(BatteryLCD);

	while(bIfiRobotDisabled == true)
	{
		if(nLCDButtons == 1)
		{
			if(counter == countMin)
			{
				counter = countMax;
			}
			else
			{
				counter--;
			}
			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}
		else if(nLCDButtons == 4)
		{
			if(counter == countMax)
			{
				counter = countMin;
			}
			else
			{
				counter++;
			}
			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}
		else if(nLCDButtons == 2)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			if(counter != countMin) autonSelect = counter;
			else sensorInit();
			wait1Msec(250);
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"Selected!");
			wait1Msec(400);
			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}
		else
		{
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"<    Select    >");
		}
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	//startTask(LiftPD);
	//startTask(ClawPD);

	startTask(BatteryLCD);

	switch(autonSelect)
	{

	case 1: //Fence Left----

		ClawTarget = ClawFlat; //Change ClawFlat to reflect updated claw potentiometer value
		while(SensorValue(potentClaw) < ClawTarget-400)
		{
			ClawClose();
		}
		ClawStop();

		//startTask(LiftPD);

		LiftTarget = LiftThrowBegin;
		while(SensorValue(potentArm) < LiftTarget-500) //Goes over the stars and etc.
		{
			ArmUp();
		}
		ArmStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -370 && SensorValue[encoderRight] > -370) //Lines up with cube.
		{
			DriveForward();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 210 && abs(SensorValue[encoderRight]) < 210)
		{
			TurnPointRight();
		}
		DriveStop();

		LiftTarget = LiftFullDown;
		while(SensorValue(potentArm) > LiftTarget)
		{
			ArmDown();
		}
		ArmStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -470 && SensorValue[encoderRight] > -470) //Goes to grab cube, first time.
		{
			DriveForward();
		}
		DriveStop();

		ClawTarget = 2000;
		while(SensorValue(potentClaw) < ClawTarget) //Closes claw on cube.
		{
			ClawClose();
		}
		wait1Msec(600);
		ClawStop();

		//stopTask(ClawPD); //Keeps the claw from continually going
		ClawStop();

		LiftTarget = LiftThrowBegin; //Begins first throwing routine.
		while(SensorValue[potentArm] < LiftTarget)
		{
			ArmUp();
		}
		ArmStop();
		wait1Msec(250);

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -150 && SensorValue[encoderRight] > -150) //Moves forward with cube a bit.
		{
			DriveForward();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 290 && abs(SensorValue[encoderRight]) < 290)
		{
			TurnPointRight();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		DriveBackwards(); //Heads over to the fence to throw.

		LiftTarget = LiftThrowRelease; //Begins throwing motion.
		while(SensorValue(potentArm) < LiftTarget)//Makes it throw earlier
		{
			ArmUp();
		}
		ArmStop();

		//startTask(ClawPD);
		ClawTarget = ClawFlat-500; //Opens claw at the height of the throw.
		while(SensorValue(potentClaw) > ClawTarget)
		{
			ClawOpen();
		}
		ClawStop();

		DriveStop();

		wait1Msec(99999999999999999999);

		break;

	case 2: //Fence Right

		ClawTarget = ClawFlat; //Change ClawFlat to reflect updated claw potentiometer value
		while(SensorValue(potentClaw) < ClawTarget-400)
		{
			ClawClose();
		}
		ClawStop();

		//startTask(LiftPD);

		LiftTarget = LiftThrowBegin;
		while(SensorValue(potentArm) < LiftTarget-500) //Goes over the stars and etc.
		{
			ArmUp();
		}
		ArmStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -370 && SensorValue[encoderRight] > -370) //Lines up with cube.
		{
			DriveForward();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 210 && abs(SensorValue[encoderRight]) < 210)
		{
			TurnPointLeft();
		}
		DriveStop();

		LiftTarget = LiftFullDown;
		while(SensorValue(potentArm) > LiftTarget)
		{
			ArmDown();
		}
		ArmStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -470 && SensorValue[encoderRight] > -470) //Goes to grab cube, first time.
		{
			DriveForward();
		}
		DriveStop();

		ClawTarget = 2000;
		while(SensorValue(potentClaw) < ClawTarget) //Closes claw on cube.
		{
			ClawClose();
		}
		wait1Msec(600);
		ClawStop();

		//stopTask(ClawPD); //Keeps the claw from continually going
		ClawStop();

		LiftTarget = LiftThrowBegin; //Begins first throwing routine.
		while(SensorValue[potentArm] < LiftTarget)
		{
			ArmUp();
		}
		ArmStop();
		wait1Msec(250);

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -150 && SensorValue[encoderRight] > -150) //Moves forward with cube a bit.
		{
			DriveForward();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 290 && abs(SensorValue[encoderRight]) < 290)
		{
			TurnPointLeft();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		DriveBackwards(); //Heads over to the fence to throw.

		LiftTarget = LiftThrowRelease; //Begins throwing motion.
		while(SensorValue(potentArm) < LiftTarget)//Makes it throw earlier
		{
			ArmUp();
		}
		ArmStop();

		//startTask(ClawPD);
		ClawTarget = ClawFlat-500; //Opens claw at the height of the throw.
		while(SensorValue(potentClaw) > ClawTarget)
		{
			ClawOpen();
		}
		ClawStop();

		DriveStop();

		wait1Msec(99999999999999999999);

		break;

		/////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////
		//Programming skills
		/////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////

	case 3:

		for(int i = 0; i<3; i++)
		{
			SensorValue[encoderLeft] = 0;
			SensorValue[encoderRight] = 0;

			ClawTarget = ClawFlat;
			while(SensorValue(potentClaw) < ClawTarget-500)
			{
				ClawClose();
			}
			ClawStop();

			startTask(LiftPD);

			LiftTarget = 2400;

			wait1Msec(2000);

			ClawTarget = 3000;
			while(SensorValue(potentClaw) < ClawTarget) //Closes claw on cube.
			{
				ClawClose();
			}
			ClawStop();

			SensorValue[encoderLeft] = 0;
			SensorValue[encoderRight] = 0;

			while(SensorValue[encoderLeft] < 1200 && SensorValue[encoderRight] < 1200)
			{
				DriveBackwards();
			}

			SensorValue[encoderLeft] = 0;
			SensorValue[encoderRight] = 0;

			LiftTarget = LiftThrowComplete; //Begins throwing motion.
			while(SensorValue(potentArm) < LiftTarget-200)//Makes it throw earlier
			{}

			DriveStop();

			ClawTarget = ClawFlat; //Opens claw at the height of the throw.
			while(SensorValue(potentClaw) > ClawTarget) //ADJUST ----------------------
			{
				ClawOpen();
			}
			ClawStop();

			wait1Msec(500);

			LiftTarget = 2400;
			while(SensorValue(potentArm) > LiftTarget) //Lowers claw.
			{}

			ClawTarget = ClawFlat; //Opens claw at the height of the throw.
			while(SensorValue(potentClaw) > ClawTarget)
			{
				ClawOpen();
			}
			ClawStop();

			SensorValue[encoderLeft] = 0;
			SensorValue[encoderRight] = 0;

			if(i<2)
			{

				SensorValue[encoderLeft] = 0;
				SensorValue[encoderRight] = 0;

				while(SensorValue[encoderLeft] > -800 && SensorValue[encoderRight] > -800) //Lines up with cube.
				{
					DriveForward();
				}

				SensorValue[encoderLeft] = 0;
				SensorValue[encoderRight] = 0;

				while(SensorValue[encoderLeft] > -600 && SensorValue[encoderRight] > -600)
				{
					DriveForwardSlow();
				}
				DriveStop();
			}

		}

		while(SensorValue[encoderLeft] > -450 && SensorValue[encoderRight] > -450) //Lines up with cube.
		{
			DriveForward();
		}
		wait1Msec(300);
		DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 350 && abs(SensorValue[encoderRight]) < 350) //CHANGE IF TURN IS WRONG
		{
			TurnPointLeft();
		}
		DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] < 650 && SensorValue[encoderRight] < 650) //Goes to grab cube, first time.
		{
			DriveBackwards();
		}
		DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > 200 && SensorValue[encoderRight] > 200) //Goes to grab cube, first time.
		{
			DriveBackwardsSlow(); // TO BE CHANGED (Use time values)
		}
		DriveStop(); //Lines up against field

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		wait1Msec(500);

		while(SensorValue[encoderLeft] > -925 && SensorValue[encoderRight] > -925) //Goes to grab cube, first time.
		{
			DriveForward();
		}
		DriveStop();

		LiftTarget = LiftFullDown+100;
		while(SensorValue(potentArm) > LiftTarget)
		{
		}

		while(SensorValue[encoderLeft] > -75 && SensorValue[encoderRight] > -75) //Goes to grab cube, first time.
		{
			DriveForward();
		}
		DriveStop();

		ClawTarget = 3000;
		while(SensorValue(potentClaw) < ClawTarget) //Closes claw on cube.
		{
			ClawClose();
		}
		ClawStop();

		//stopTask(ClawPD); //Keeps the claw from continually going
		ClawStop();

		LiftTarget = LiftThrowBegin+200; //Begins first throwing routine.
		wait1Msec(250);

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -600 && SensorValue[encoderRight] > -600) //Moves forward with cube a bit.
		{
			DriveForward();
		}
		DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -50 && SensorValue[encoderRight] > -50) //Moves forward with cube a bit.
		{
			DriveForwardSlow();
		}
		DriveStop();

		wait1Msec(500); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] < 250 && SensorValue[encoderRight] < 250) //Moves forward with cube a bit.
		{
			DriveBackwards();
		}
		DriveStop();

		wait1Msec(500); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 260 && abs(SensorValue[encoderRight]) < 260) //CHECK IF NOT TURNING RIGHT
		{
			TurnPointRight();
		}
		DriveStop();

		wait1Msec(500); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		DriveBackwards(); //Heads over to the fence to throw.
		////////////////////
		LiftTarget = LiftThrowRelease +250; //Begins throwing motion.
		while(SensorValue(potentArm) < LiftTarget)//Makes it throw earlier
		{
		}

		//startTask(ClawPD);
		ClawTarget = ClawFlat-500; //Opens claw at the height of the throw.
		while(SensorValue(potentClaw) > ClawTarget)
		{
			ClawOpen();
		}
		ClawStop();

		DriveStop();

		LiftTarget = LiftFullDown; //Returns the claw to a down position.
		while(SensorValue(potentArm) > LiftFullDown)
		{
		}

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -750 && SensorValue[encoderRight] > -750) //Goes to grab stars.
		{
			DriveForward();
		}
		DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		ClawTarget = 3000; //Grabs stars.
		while(SensorValue(potentClaw) < ClawTarget)
		{
			ClawClose();
		}
		wait1Msec(250);
		ClawStop();

		DriveBackwards();
		wait1Msec(500);
		DriveStop();
		DriveForward();
		wait1Msec(250);
		ClawOpen();
		wait1Msec(250);
		DriveStop();
		ClawClose();
		wait1Msec(1000);
		ClawStop();

		LiftTarget = LiftThrowBegin;
		wait1Msec(250);

		DriveBackwards();

		LiftTarget = LiftThrowRelease + 250;
		while(SensorValue(potentArm) < LiftTarget)
		{
		}

		DriveStop();

		//startTask(ClawPD);
		ClawTarget = ClawFlat;
		while(SensorValue(potentClaw) > ClawTarget)
		{
			ClawOpen();
		}
		ClawStop();

		DriveStop(); //This may need to be edited for the throw
		stopTask(LiftPD);
		ArmStop();
		wait1Msec(99999999999999999999);

		break;

	case 4: //Backs up, that's it.

		ClawTarget = ClawFlat;
		while(SensorValue(potentClaw) < ClawTarget-500)
		{
			ClawClose();
		}
		ClawStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		LiftTarget = LiftThrowBegin; //Begins first throwing routine.
		while(SensorValue[potentArm] < LiftTarget+950)
		{
			ArmUp();
			DriveBackwards();
		}
		wait1Msec(750);
		ArmStop();

		while(SensorValue[encoderLeft] < 500 && SensorValue[encoderRight] < 500)
		{
			DriveBackwards();
		}
		DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		//while(SensorValue[encoderLeft] > -600 && SensorValue[encoderRight] > -600)
		//{
		//	DriveForward();
		//
		//DriveStop();

		wait1Msec(99999999999);

		break;

	case 5: //CloseLeft///////////////////////////////////////////////////////

		ClawTarget = ClawFlat; //Change ClawFlat to reflect updated claw potentiometer value
		while(SensorValue(potentClaw) < ClawTarget-400)
		{
			ClawClose();
		}
		ClawStop();

		//while(SensorValue[encoderLeft] > -50 && SensorValue[encoderRight] > -50) //Lines up with cube.
		//{
		//	DriveForward();
		//}
		//DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		LiftTarget = LiftThrowBegin;
		while(SensorValue(potentArm) < LiftTarget-500) //Goes over the stars and etc.
		{
			ArmUp();
		}
		ArmStop();

		while(SensorValue[encoderLeft] > -50 && SensorValue[encoderRight] > -50) //Lines up with cube.
		{
			DriveForward();
		}
		DriveStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 900)
		{
			TurnSwingRight();
		}

		DriveStop();

		///

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		LiftTarget = LiftFullDown;
		while(SensorValue(potentArm) > LiftTarget)
		{
			ArmDown();
		}
		ArmStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -470 && SensorValue[encoderRight] > -470) //Goes to grab cube, first time.
		{
			DriveForward();
		}
		DriveStop();

		ClawTarget = 2000;
		while(SensorValue(potentClaw) < ClawTarget) //Closes claw on cube.
		{
			ClawClose();
		}
		wait1Msec(600);
		ClawStop();

		//Clumping
		//DriveForward();
		//wait1Msec(450);
		//ClawOpen();
		//DriveStop();
		//wait1Msec(500);
		//ClawClose();
		//wait1Msec(600);
		//ClawStop();
		//DriveStop();

		LiftTarget = LiftThrowBegin; //Begins first throwing routine.
		while(SensorValue[potentArm] < LiftTarget)
		{
			ArmUp();
		}
		ArmStop();
		wait1Msec(100);

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] < 700 && SensorValue[encoderRight] < 700) //Backs up with cube to wall
		{
			DriveBackwards();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		//while(SensorValue[encoderLeft] > -150 && SensorValue[encoderRight] > -150) //Goes forward from wall
		//{
		//	DriveForward();
		//}
		//DriveStop();

		//wait1Msec(250); //Waits for momentum to die

		//SensorValue[encoderLeft] = 0;
		//SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 150 && abs(SensorValue[encoderRight]) < 150)
		{
			TurnPointRight();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		DriveBackwards(); //Heads over to the fence to throw.

		LiftTarget = LiftThrowRelease; //Begins throwing motion.
		while(SensorValue(potentArm) < LiftTarget)//Makes it throw earlier
		{
			ArmUp();
		}
		ArmStop();

		//startTask(ClawPD);
		ClawTarget = ClawFlat-100; //Opens claw at the height of the throw.
		while(SensorValue(potentClaw) > ClawTarget)
		{
			ClawOpen();
		}
		ClawStop();
		wait1Msec(250);
		ClawTarget = 2000; //Opens claw at the height of the throw.
		while(SensorValue(potentClaw) < ClawTarget)
		{
			ClawClose();
		}

		DriveStop();

		wait1Msec(99999999999999999999);

		break;

	case 6: //CloseRight

		ClawTarget = ClawFlat; //Change ClawFlat to reflect updated claw potentiometer value
		while(SensorValue(potentClaw) < ClawTarget-400)
		{
			ClawClose();
		}
		ClawStop();

		//startTask(LiftPD);

		LiftTarget = LiftThrowBegin;
		while(SensorValue(potentArm) < LiftTarget-500) //Goes over the stars and etc.
		{
			ArmUp();
		}
		ArmStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -370 && SensorValue[encoderRight] > -370) //Lines up with cube.
		{
			DriveForward();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 210 && abs(SensorValue[encoderRight]) < 210)
		{
			TurnPointLeft();
		}
		DriveStop();

		LiftTarget = LiftFullDown;
		while(SensorValue(potentArm) > LiftTarget)
		{
			ArmDown();
		}
		ArmStop();

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] > -470 && SensorValue[encoderRight] > -470) //Goes to grab cube, first time.
		{
			DriveForward();
		}
		DriveStop();

		ClawTarget = 2000;
		while(SensorValue(potentClaw) < ClawTarget) //Closes claw on cube.
		{
			ClawClose();
		}
		wait1Msec(600);
		ClawStop();

		//stopTask(ClawPD); //Keeps the claw from continually going
		ClawStop();

		LiftTarget = LiftThrowBegin; //Begins first throwing routine.
		while(SensorValue[potentArm] < LiftTarget)
		{
			ArmUp();
		}
		ArmStop();
		wait1Msec(100);

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		while(SensorValue[encoderLeft] < 600 && SensorValue[encoderRight] < 600) //Backs up with cube to wall
		{
			DriveBackwards();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		//while(SensorValue[encoderLeft] > -150 && SensorValue[encoderRight] > -150) //Goes forward from wall
		//{
		//	DriveForward();
		//}
		//DriveStop();

		//wait1Msec(250); //Waits for momentum to die

		//SensorValue[encoderLeft] = 0;
		//SensorValue[encoderRight] = 0;

		while(abs(SensorValue[encoderLeft]) < 250 && abs(SensorValue[encoderRight]) < 250)
		{
			TurnPointLeft();
		}
		DriveStop();

		wait1Msec(250); //Waits for momentum to die

		SensorValue[encoderLeft] = 0;
		SensorValue[encoderRight] = 0;

		DriveBackwards(); //Heads over to the fence to throw.

		LiftTarget = LiftThrowRelease; //Begins throwing motion.
		while(SensorValue(potentArm) < LiftTarget)//Makes it throw earlier
		{
			ArmUp();
		}
		ArmStop();

		//startTask(ClawPD);
		ClawTarget = ClawFlat-500; //Opens claw at the height of the throw.
		while(SensorValue(potentClaw) > ClawTarget)
		{
			ClawOpen();
		}
		ClawStop();

		DriveStop();

		wait1Msec(99999999999999999999);

		break;
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop

	//startTask(SoundControl);
	startTask(DriveControl);
	startTask(ClawPD);
	startTask(LiftPD);
	startTask(BatteryLCD);

	while(1==1)
	{
		wait1Msec(1000);
	}
}
