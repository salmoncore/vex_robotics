#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    potentRight,    sensorPotentiometer)
#pragma config(Sensor, in2,    potentLeft,     sensorPotentiometer)
#pragma config(Sensor, in3,    stackgyro,      sensorGyro)
#pragma config(Sensor, in4,    stackgyro2,     sensorGyro)
#pragma config(Sensor, in8,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  jumper,         sensorNone)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           baseBackRight, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           baseFrontRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           moverRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           moverLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           liftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           MobileGoal,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           baseFrontLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          baseBackLeft,  tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

bool songplayed;

int leftError, rightError, driveTarget, driveMax = 127;
float leftResult, rightResult, kp = 0.52;

int gyroError, gyroTarget;
float gyroResult, gyrokp = 0.52; //Was 0.52

bool liftToggle = false;
int AutonLiftTarget, AutonLiftErrorLeft,AutonLiftErrorRight, AutonLiftLastErrorLeft,AutonLiftLastErrorRight;
float liftKP = 0.60, liftKD = 0.19;

bool stackToggle = false;
int AutonStackTargetLeft, AutonStackTargetRight, AutonStackErrorLeft,AutonStackErrorRight, AutonStackLastErrorLeft,AutonStackLastErrorRight;
float stackKP = 0.17, stackKD = 0.29;

int RollerControl = 0;

void LiftSet(int power);
task resetIndicate();

// Start of functions

void DriveForwardP()
{
	leftError = 1000;
	rightError = 1000;

	while(abs(leftError) > 7 && abs(rightError) > 7) //was 400
	{
		leftError = driveTarget - SensorValue[leftEncoder];
		rightError = driveTarget - SensorValue[rightEncoder];

		leftResult = leftError * kp;
		rightResult = rightError * kp;

		if(leftResult > driveMax) leftResult = driveMax;
		else if(leftResult < driveMax*-1) leftResult = driveMax*-1;

		if(rightResult > driveMax) rightResult = driveMax;
		else if(rightResult < driveMax*-1) rightResult = driveMax*-1;

		motor[baseFrontLeft] = leftResult;
		motor[baseFrontRight] = rightResult;
		motor[baseBackLeft] = leftResult;
		motor[baseBackRight] = rightResult;

		wait1Msec(20);
	}

}

void DriveBackwardP()
{
	leftError = 1000;
	rightError = 1000;
	while((abs(leftError) > 7 && abs(rightError) > 7)) //was 400
	{
		leftError = driveTarget - SensorValue[leftEncoder];
		rightError = driveTarget - SensorValue[rightEncoder];

		leftResult = leftError * kp;
		rightResult = rightError * kp;

		if(leftResult > driveMax) leftResult = driveMax;
		else if(leftResult < driveMax*-1) leftResult = driveMax*-1;

		if(rightResult > driveMax) rightResult = driveMax;
		else if(rightResult < driveMax*-1) rightResult = driveMax*-1;

		motor[baseFrontLeft] = leftResult;
		motor[baseFrontRight] = rightResult;
		motor[baseBackLeft] = leftResult;
		motor[baseBackRight] = rightResult;

		wait1Msec(20);
	}

}

void TurnPointP() //Check the bottom where the motor values are set if not working.
{
	gyroError = gyroTarget - SensorValue[gyro];
	while(abs(gyroError) > 10) //was 400
	{
		gyroError = gyroTarget - SensorValue[gyro];

		gyroResult = gyroError * gyrokp;

		//if(leftResult > driveMax) leftResult = driveMax;
		//else if(leftResult < driveMax*-1) leftResult = driveMax*-1;

		if(gyroResult > driveMax) gyroResult = driveMax;
		else if(gyroResult < driveMax*-1) gyroResult = driveMax*-1;

		//motor[baseLeft] = gyroResult;
		//motor[baseRight] = (gyroResult * -1);

		motor[baseFrontLeft] = gyroResult * -1;
		motor[baseFrontRight] = (gyroResult );
		motor[baseBackLeft] = gyroResult * -1;
		motor[baseBackRight] = (gyroResult);

		wait1Msec(20);
	}

}

task AutonLiftControl(){
	while(1==1){
		if(liftToggle == true){
			AutonLiftErrorLeft = SensorValue[potentLeft] - (AutonLiftTarget -35);
			AutonLiftErrorRight = SensorValue[potentRight] - AutonLiftTarget;

			float leftP = AutonLiftErrorLeft * liftKP;
			float rightP = AutonLiftErrorRight * liftKP;

			float leftD = AutonLiftLastErrorLeft - AutonLiftErrorLeft;
			float rightD = AutonLiftLastErrorRight - AutonLiftErrorRight;

			leftD *= liftKD;
			rightD *= liftKD;

			AutonLiftLastErrorLeft = AutonLiftErrorLeft;
			AutonLiftLastErrorRight = AutonLiftErrorRight;

			float leftFinal = leftP + leftD;
			float rightFinal = rightP + rightD;

			if(leftFinal > 65) leftFinal = 65;
			if(rightFinal > 65) rightFinal = 65;

			if(leftFinal < -30) motor[liftLeft] = (leftFinal * -1) * (0.72);
			else motor[liftLeft] = (leftFinal * -1);
			motor[liftRight] = rightFinal * -1;
		}


		wait1Msec(20);
	}
}


task ManualLiftControl(){
	while(1==1){
		if(vexRT[Btn8U] == 1){
			//liftToggle = true;
			//AutonLiftTarget = 1650;
		}
		else if(vexRT[Btn8L] == 1){
			liftToggle = true;
			AutonLiftTarget = 2100;
		}
		else if(vexRT[Btn6U] == 1){
			liftToggle = false;
			LiftSet(127);
		}
		else if(vexRT[Btn6D] == 1){
			liftToggle = false;
			LiftSet(-70);
		}
		else{
			if(liftToggle == false) LiftSet(0);
		}
		wait1Msec(20);
	}
}

task ManualLiftControl2(){
	AutonLiftTarget = 2300;
	liftToggle = true;
	while(1==1){
		//if(vexRT[Btn8U] == 1){
		//	liftToggle = false;
		//	AutonLiftTarget = 1850;
		//}
		if(vexRT[Btn8L] == 1){
			liftToggle = true;
			AutonLiftTarget = 2300;
		}
		else if(vexRT[Btn6U] == 1){
			liftToggle = true;
			AutonLiftTarget += 70;
			if(AutonLiftTarget > 2800) AutonLiftTarget = 2800;
			wait1Msec(20);
		}
		else if(vexRT[Btn6D] == 1){
			liftToggle = true;
			AutonLiftTarget -= 60;
			if(AutonLiftTarget < 1500) AutonLiftTarget = 1500;
			wait1Msec(20);
		}
		else{
			if(liftToggle == false) LiftSet(0);
		}
		wait1Msec(20);
	}
}

task AutonStackControl(){
	float leftstackKP, rightstackKP, 	leftstackKD, rightstackKD;

	while(1==1){
		if(stackToggle == true){
			AutonStackErrorLeft = (AutonStackTargetLeft) - SensorValue[stackgyro2] * -1;
			AutonStackErrorRight = (AutonStackTargetRight) - SensorValue[stackgyro];

			if(abs(AutonStackErrorLeft) < 200){
				leftstackKP = 0.17;
				leftstackKD = 0.37;
			}
			else{
				leftstackKP = 0.27;
				leftstackKD = 0.42;
			}

			if(abs(AutonStackErrorRight) < 200){
				rightstackKP = 0.17;
				rightstackKD = 0.37;
			}
			else{
				rightstackKP = 0.27;
				rightstackKD = 0.42;
			}


			float leftP = AutonStackErrorLeft * leftstackKP;
			float rightP = AutonStackErrorRight * rightstackKP;

			float leftD = AutonStackLastErrorLeft - AutonStackErrorLeft;
			float rightD = AutonStackLastErrorRight - AutonStackErrorRight;

			leftD *= leftstackKD;
			rightD *= rightstackKD;

			AutonStackLastErrorLeft = AutonStackErrorLeft;
			AutonStackLastErrorRight = AutonStackErrorRight;

			float leftFinal = leftP + leftD;
			float rightFinal = rightP + rightD;

			//if(leftFinal > 65) leftFinal = 65;
			//if(rightFinal > 65) rightFinal = 65;

			motor[moverLeft] = (leftFinal * 1);
			motor[moverRight] = rightFinal * 0.95;
		}

		wait1Msec(20);
	}
}
task ManualIntakeControl(){
	while(1==1){
		if(vexRT[Btn8R] == 1)
		{
			motor[Intake] = 75;
			RollerControl = 1;
		}
		else if(vexRT[Btn8D] == 1)
		{
			motor[Intake] = -75;
			RollerControl = 0;
		}
		else
		{
			if(RollerControl == 1)
			{
				motor[Intake] = 20;
			}
			else if(RollerControl == 0)
			{
				motor[Intake] = 0;
			}
		}
		wait1Msec(20);
	}
}
task ManualStackControl(){
	bool holdToggle = false;
	while(1==1){
		if(vexRT[Btn7U] == 1){
			stackToggle = true;
			AutonStackTargetLeft = 0;
			AutonStackTargetRight = 0;
		}
		else if(vexRT[Btn7R] == 1){

			startTask(resetIndicate);
			holdToggle = false;
			SensorValue[stackgyro] = 0;
			SensorValue[stackgyro2] = 0;
		}
		else if(vexRT[Btn7L] == 1){
			stackToggle = false;
			holdToggle = false;
			motor[moverLeft] = 127;
			motor[moverRight] = 127;
		}
		else if(vexRT[Btn7D] == 1){
			stackToggle = false;
			holdToggle = false;
			motor[moverLeft] = -127;
			motor[moverRight] = -127;
		}
		else{
			if(holdToggle == false){
				if(SensorValue[stackgyro] < -220){
					AutonStackTargetLeft = SensorValue[stackgyro2] * -1;
					AutonStackTargetRight = SensorValue[stackgyro];
					holdToggle = true;
				}
				else{
					motor[moverLeft] = 0;
					motor[moverRight] = 0;
				}

			}
			else{
				stackToggle = true;
			}
			//if(stackToggle == false){
			//	motor[moverLeft] = 0;
			//	motor[moverRight] = 0;
			//}

		}
		wait1Msec(20);
	}
}

task AutoStackSequence(){
	while(1==1){
		if(vexRT[Btn8U] == 1){
			stopTask(ManualLiftControl);
			stopTask(ManualStackControl);
			stopTask(ManualIntakeControl);

			int startposition = SensorValue[potentLeft];


			//AutonLiftTarget = startposition + 250;
			//liftToggle = true;
			//waitUntil(abs(AutonLiftErrorLeft) > 5);
			LiftSet(127);
			wait1Msec(300);
			LiftSet(0);
			wait1Msec(500);


			//AutonStackTarget = 0;
			stackToggle = true;
			waitUntil((abs(AutonStackErrorLeft) < 10) || (abs(AutonStackErrorRight) < 10));

			liftToggle = false;
			LiftSet(-60);
			wait1Msec(500);
			motor[Intake] = -127;
			wait1Msec(100);
			LiftSet(0);
			wait1Msec(100);
			LiftSet(127);
			wait1Msec(600);
			LiftSet(0);

			//AutonStackTarget = -900;
			waitUntil(abs(AutonStackErrorLeft) > 5);

			LiftSet(-80);
			wait1Msec(300);
			LiftSet(0);
			motor[Intake] = 0;
			stackToggle = false;


			startTask(ManualIntakeControl);
			startTask(ManualLiftControl);
			startTask(ManualStackControl);
		}

		wait1Msec(20);
	}
}

task resetIndicate(){
	playTone(1046.5,10);
	stopTask(resetIndicate);
}

void Bepis2()
{
	playTone(783.99,12.5); //g
	playTone(659.25,12.5); //e
	playTone(523.25,25); //c
	playTone(523.25,25); //c
	playTone(523.25,12.5); //c
	playTone(587.33,12.5); //d
	playTone(659.25,12.5); //e
	playTone(698.46,12.5); //f
	playTone(783.99,25); //g
	playTone(783.99,25); //g
	playTone(783.99,25); //g
	playTone(659.25,50); //e
}

void Bepis()
{
	if(!songplayed){
		playTone(659.25,12.5);
		playTone(783.99,12.5);
		playTone(1046.50,12.5);
		playTone(1318.51,25);
		playTone(1046.50,25);
		playTone(1567.98,50);
		songplayed = true;
	}

	void Bepis3()
	{


	}

}

void EncoderReset()
{
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

float levelKP = 0.04
;
void LiftSet(int power)
{

	//int error = (SensorValue[potentLeft] ) - (SensorValue[potentRight] + 20 );
	int error = (SensorValue[potentRight] + 21) - (SensorValue[potentLeft] + 0) ;

	float result = error * levelKp;

	if(error > 1)
	{
		motor[liftLeft] = power - result;
		motor[liftRight] = power ;
	}

	else if(error < -1)
	{
		motor[liftLeft] = power;
		motor[liftRight] = power - result;
	}
	else
	{
		motor[liftLeft] = power;
		motor[liftRight] = power;
	}

}

void DriveForward()
{
	motor[baseFrontLeft] = 127;
	motor[baseFrontRight] = 127;
	motor[baseBackLeft] = 127;
	motor[baseBackRight] = 127;
}

void DriveBackward()
{
	motor[baseFrontLeft] = -127;
	motor[baseFrontRight] = -127;
	motor[baseBackLeft] = -127;
	motor[baseBackRight] = -127;
}

void DriveForwardSlow()
{
	motor[baseFrontLeft] = 127/3;
	motor[baseFrontRight] = 127/3;
	motor[baseBackLeft] = 127/3;
	motor[baseBackRight] = 127/3;
}

void DriveBackwardSlow()
{
	motor[baseFrontLeft] = -127/3;
	motor[baseFrontRight] = -127/3;
	motor[baseBackLeft] = -127/3;
	motor[baseBackRight] = -127/3;
}

void DriveStop()
{
	motor[baseFrontLeft] = 0;
	motor[baseFrontRight] = 0;
	motor[baseBackLeft] = 0;
	motor[baseBackRight] = 0;
}

void TurnPointLeft()
{
	motor[baseFrontLeft] = -127;
	motor[baseFrontRight] = 127;
	motor[baseBackLeft] = -127;
	motor[baseBackRight] = 127;
}

void TurnPointRight()
{
	motor[baseFrontLeft] = 127;
	motor[baseFrontRight] = -127;
	motor[baseBackLeft] = 127;
	motor[baseBackRight] = -127;
}

void TurnPointLeftSlow()
{
	motor[baseFrontLeft] = -127/2;
	motor[baseFrontRight] = 127/2;
	motor[baseBackLeft] = -127/2;
	motor[baseBackRight] = 127/2;
}

void TurnPointRightSlow()
{
	motor[baseFrontLeft] = 127/2;
	motor[baseFrontRight] = -127/2;
	motor[baseBackLeft] = 127/2;
	motor[baseBackRight] = -127/2;
}

void TurnSwingRight()
{
	motor[baseFrontLeft] = 127;
	motor[baseFrontRight] = 0;
	motor[baseBackLeft] = 127;
	motor[baseBackRight] = 0;
}

void TurnSwingLeft()
{
	motor[baseFrontLeft] = 0;
	motor[baseFrontRight] = 127;
	motor[baseBackLeft] = 0;
	motor[baseBackRight] = 127;
}

void MGUp()
{
	motor[MobileGoal] = 127;
}

void MGDown()
{
	motor[MobileGoal] = -127;
}

void MGStop()
{
	motor[MobileGoal] = 0;
}

void IntakeUp()
{
	motor[Intake] = 127;
}

void IntakeDown()
{
	motor[Intake] = -80; //Turned down to prevent cone flipping?
}

void IntakeStop()
{
	motor[Intake] = 0;
}

void MoverUp()
{
	motor[moverLeft] = 127;
	motor[moverRight] = 127;
}

void MoverDown()
{
	motor[moverLeft] = -127;
	motor[moverRight] = -127;
}

void MoverStop()
{
	motor[moverLeft] = 0;
	motor[moverRight] = 0;
}

void IntakeHold()
{
	motor[Intake] = 20;
}

void BaseReset()
{
	SensorValue(rightEncoder) = 0;
	SensorValue(leftEncoder) = 0;
}

void sensorInit() // The function for initalizing the gyroscope, includes all the waits and etc.
{
	//Gyroscope in analog port 1
	SensorType[stackgyro] = sensorNone;
	SensorType[stackgyro2] = sensorNone;
	SensorType[Gyro] = sensorNone;
	wait1Msec(250);
	SensorType[Gyro] = sensorGyro;
	SensorType[stackgyro] = sensorGyro;
	SensorType[stackgyro2] = sensorGyro;
	wait1Msec(2550);
	playTone(440,25);
}

int autonSelect = 1; //Default Autonomous

void pre_auton()
{

	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	int countMin = 0;
	int countMax = 10;
	int counter = countMin;
	string str[11] = {"GyroInit","5pt BL/RR","5pt BR/RL","1C High","Stack RL","Stack BR","6","7","8","9","10"}; //Program Names
	bLCDBacklight = true;
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;
	sensorInit();

	while(bIfiRobotDisabled == true)
	{

		if(nLCDButtons == 1)
		{
			if(counter == countMin)
			{
				counter = countMax;
			}

			else
			{
				counter--;
			}

			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else if(nLCDButtons == 4)
		{
			if(counter == countMax)
			{
				counter = countMin;
			}

			else
			{
				counter++;
			}

			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else if(nLCDButtons == 2)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			if(counter != countMin) autonSelect = counter;
			else sensorInit(); //Should this have been commented? ------------
				wait1Msec(250);
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"Selected!");
			wait1Msec(400);
			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else
		{
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"<    Select    >");
		}

	}

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

bool sequenceComp = false;

task openingSequence(){
	IntakeUp();
	wait1Msec(250);
	IntakeHold();

	while(SensorValue[potentLeft] < 1800 && SensorValue[potentRight] < 1800)
	{
		LiftSet(127);
	}
	LiftSet(0);

	MGDown();
	wait1Msec(1600);
	MGStop();

	sequenceComp = true;
}

task stationaryStart(){

	//while(SensorValue[potentLeft] < 2000 && SensorValue[potentRight] < 2000)
	//{
	//	LiftSet(127);
	//}
	//LiftSet(0);

	BaseReset();
	driveTarget = 450;
	driveMax = 127;
	DriveForwardP();
	DriveStop();

	sequenceComp = true;

}

task DropCone(){
	while(SensorValue[potentLeft] > 1500 && SensorValue[potentRight] > 1400)
	{
		LiftSet(-100);
	}
	LiftSet(0);

	IntakeDown();
	wait1Msec(450);
	while(SensorValue[potentLeft] < 1800 && SensorValue[potentRight] < 1800)
	{
		LiftSet(127);
	}
	LiftSet(0);
	IntakeStop();

	sequenceComp = true;
}

task autonomous()
{

	int DriveSpeed = 127; //Drive Speed
	int TurnSpeed = 100;

	switch(autonSelect)
	{

	case 1: //5pt BL/RR

		startTask(AutonLiftControl);
		startTask(AutonStackControl);
		stackToggle = true;

		startTask(openingSequence);

		BaseReset();
		driveTarget = 750;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		waitUntil(sequenceComp == true);

		DriveForward();
		wait1Msec(750);
		DriveStop();

		MGUp();
		wait1Msec(2000);
		MGStop();

		//lift comes down, mover centers to drop preload

		BaseReset();
		LiftSet(0);

		while(SensorValue[potentLeft] > 1500 && SensorValue[potentRight] > 1400)
		{
			LiftSet(-100);
		}
		LiftSet(0);

		IntakeDown();
		wait1Msec(450);
		while(SensorValue[potentLeft] < 1800 && SensorValue[potentRight] < 1800)
		{
			LiftSet(127);
		}
		LiftSet(0);
		IntakeStop();

		//MGDown();
		//wait1Msec(750);
		//MGStop();

		//DriveForward();
		//wait1Msec(1000);
		//DriveStop();

		//MGUp();
		//wait1Msec(1200);
		//MGStop();

		driveTarget = -800; //Was -1000
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = TurnSpeed;
		gyroTarget = -2000; //Was -1900
		TurnPointP();
		DriveStop();

		MGDown();
		BaseReset();
		driveTarget = 200;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		wait1Msec(750);
		MGStop();

		BaseReset();
		driveTarget = -300;
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		break;

	case 2: //5pt BR/RL

		startTask(AutonLiftControl);
		startTask(AutonStackControl);
		stackToggle = true;

		startTask(openingSequence);

		BaseReset();
		driveTarget = 750;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		waitUntil(sequenceComp == true);

		DriveForward();
		wait1Msec(750);
		DriveStop();

		MGUp();
		wait1Msec(2000);
		MGStop();

		//lift comes down, mover centers to drop preload

		BaseReset();
		LiftSet(0);

		while(SensorValue[potentLeft] > 1500 && SensorValue[potentRight] > 1400)
		{
			LiftSet(-100);
		}
		LiftSet(0);

		IntakeDown();
		wait1Msec(450);
		while(SensorValue[potentLeft] < 1800 && SensorValue[potentRight] < 1800)
		{
			LiftSet(127);
		}
		LiftSet(0);
		IntakeStop();

		//MGDown();
		//wait1Msec(750);
		//MGStop();

		//DriveForward();
		//wait1Msec(1000);
		//DriveStop();

		//MGUp();
		//wait1Msec(1200);
		//MGStop();

		driveTarget = -800; //Was -1000
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = TurnSpeed;
		gyroTarget = 2000; // Was -1900
		TurnPointP();
		DriveStop();

		MGDown();
		BaseReset();
		driveTarget = 200;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		wait1Msec(750);
		MGStop();

		BaseReset();
		driveTarget = -300;
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		break;

	case 3: //Stationary 1 Cone

		startTask(AutonLiftControl);
		startTask(AutonStackControl);
		stackToggle = true;

		startTask(stationaryStart);

		//BaseReset();
		//driveTarget = 420;
		//driveMax = DriveSpeed;
		//DriveForwardP();
		//DriveStop();

		while(SensorValue[potentLeft] < 2000 && SensorValue[potentRight] < 2000)
		{
			LiftSet(127);
		}
		LiftSet(0);

		waitUntil(sequenceComp == true);

		while(SensorValue[potentLeft] > 1950 && SensorValue[potentRight] > 1950)
		{
			LiftSet(-50);
		}
		LiftSet(0);

		IntakeDown();
		wait1Msec(300);
		while(SensorValue[potentLeft] < 2000 && SensorValue[potentRight] < 2000)
		{
			LiftSet(127);
		}
		LiftSet(0);
		IntakeStop();

		DriveBackward();
		wait1Msec(500);
		DriveStop();

		break;

	case 4: //Auto Stack RL

		startTask(AutonLiftControl);
		startTask(AutonStackControl);
		stackToggle = true;

		startTask(openingSequence);

		BaseReset();
		driveTarget = 700;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		waitUntil(sequenceComp == true);

		BaseReset();
		driveTarget = 600;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		MGUp();
		wait1Msec(1750);
		MGStop();

		//lift comes down, mover centers to drop preload

		BaseReset();
		LiftSet(0);

		while(SensorValue[potentLeft] > 1500 && SensorValue[potentRight] > 1400)
		{
			LiftSet(-127);
		}
		LiftSet(0);

		IntakeDown();
		wait1Msec(500);
		IntakeStop();

		while(SensorValue[potentLeft] < 1650 && SensorValue[potentRight] < 1650)
		{
			LiftSet(100);
		}
		LiftSet(0);

		BaseReset();
		driveTarget = -800; //Backs up to loader
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = 110;
		gyroTarget = 350;
		TurnPointP();
		DriveStop();

		stackToggle = false;

		//Grabs cone off of stack

		IntakeUp();
		MoverDown();
		waitUntil(SensorValue[stackgyro2] > 1100);
		//wait1Msec(250);
		IntakeHold();
		MoverStop();

		stackToggle = true;

		BaseReset();
		driveTarget = -400;
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = TurnSpeed;
		gyroTarget = 1400;
		TurnPointP();
		DriveStop();

		sequenceComp = false;

		startTask(DropCone);

		wait1Msec(1000);

		MGDown();

		waitUntil(sequenceComp == true);

		wait1Msec(1000);

		DriveBackward();
		wait1Msec(500);
		MGStop();
		wait1Msec(500);
		DriveStop();

		break;

	case 5: //Auto Stack RL

		startTask(AutonLiftControl);
		startTask(AutonStackControl);
		stackToggle = true;

		startTask(openingSequence);

		BaseReset();
		driveTarget = 700;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		waitUntil(sequenceComp == true);

		BaseReset();
		driveTarget = 600;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		MGUp();
		wait1Msec(1750);
		MGStop();

		//lift comes down, mover centers to drop preload

		BaseReset();
		LiftSet(0);

		while(SensorValue[potentLeft] > 1500 && SensorValue[potentRight] > 1400)
		{
			LiftSet(-127);
		}
		LiftSet(0);

		IntakeDown();
		wait1Msec(500);
		IntakeStop();

		while(SensorValue[potentLeft] < 1650 && SensorValue[potentRight] < 1650)
		{
			LiftSet(100);
		}
		LiftSet(0);

		BaseReset();
		driveTarget = -800; //Backs up to loader
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = 110;
		gyroTarget = -350;
		TurnPointP();
		DriveStop();

		stackToggle = false;

		//Grabs cone off of stack

		IntakeUp();
		MoverDown();
		waitUntil(SensorValue[stackgyro2] > 1100);
		//wait1Msec(250);
		IntakeHold();
		MoverStop();

		stackToggle = true;

		BaseReset();
		driveTarget = -400;
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = 127;
		gyroTarget = -1400;
		TurnPointP();
		DriveStop();

		sequenceComp = false;

		startTask(DropCone);

		wait1Msec(1000);

		MGDown();

		waitUntil(sequenceComp == true);

		wait1Msec(1000);

		DriveBackward();
		wait1Msec(500);
		MGStop();
		wait1Msec(500);
		DriveStop();

		break;

	case 6: //


		break;

	case 7: //


		break;

	case 8: //


		break;

	case 9: //


		break;

	case 10: //


		break;

	}

}

task Horn()
{
	while (1==1)
	{
		if(vexRT[Btn8U] == 1)
		{
			Bepis();
		}
		wait1Msec(20);
	}
}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{



	startTask(Horn);
	startTask(ManualLiftControl);
	startTask(ManualStackControl);
	startTask(ManualIntakeControl);
	//startTask(ManualLiftControl2);
	startTask(AutonLiftControl);
	startTask(AutonStackControl);
	//startTask(AutoStackSequence);
	while(1==1)
	{

		//DRIVE CONTROL
		motor[baseFrontLeft] = (vexRT[Ch3] + vexRT[Ch1]) + (vexRT[Ch3Xmtr2] + vexRT[Ch1Xmtr2]);
		motor[baseBackLeft] = (vexRT[Ch3] + vexRT[Ch1]) + (vexRT[Ch3Xmtr2] + vexRT[Ch1Xmtr2]);
		motor[baseFrontRight] = (vexRT[Ch3] - vexRT[Ch1]) + (vexRT[Ch3Xmtr2] - vexRT[Ch1Xmtr2]);
		motor[baseBackRight] = (vexRT[Ch3] - vexRT[Ch1]) + (vexRT[Ch3Xmtr2] - vexRT[Ch1Xmtr2]);

		//Primary Controller ------------

		//LIFT CONTROL

		//if(vexRT[Btn6U] == 1)
		//{
		//	LiftSet(127);
		//}
		//else if(vexRT[Btn6D] == 1)
		//{
		//	LiftSet(-70);
		//}
		//else
		//{
		//	LiftSet(0);
		//}
		/*if(condition) {
			//code
		}
		else {
			//code
		}*/

		//MOVER CONTROL
		//motor[moverLeft] = (vexRT[Btn7L] * 127) - (vexRT[Btn7D] * 127);
		//motor[moverRight] = (vexRT[Btn7L] * 127) - (vexRT[Btn7D] * 127);

		//INTAKE CONTROL



		//MG CONTROL
		motor[MobileGoal] = (vexRT[Btn5U] * 127) - (vexRT[Btn5D] * 127);

		//Secondary Controller ------------

		wait1Msec(20);

	}

}
