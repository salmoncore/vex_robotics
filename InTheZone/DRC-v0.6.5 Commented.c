#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    ArmPotentR,     sensorPotentiometer)
#pragma config(Sensor, in2,    ArmPotentL,     sensorPotentiometer)
#pragma config(Sensor, in6,    LockPotent,     sensorPotentiometer)
#pragma config(Sensor, in7,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  jumper,         sensorTouch)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           mgLeft,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lock,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           baseRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           baseLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           liftLeftUp,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftLeftDown,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           liftRightUp,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           liftRightDown, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mgRight,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//For TSA, I'll comment this garbage for you.
//SO, HERE'S THE CONDENSED DIRECTORY OF WHERE THINGS ARE
//Here's about how it's structured (might be a line or two off):
//- PRAGMA: 1-18 (lmao)
//- Functions: 68-431
//-- PID Loops: 68-139
//-- Procedures: 141-353
//- Autonomous: 443-1104
//-- 15 Second Autonomous for Red and Blue: 445, 704
//-- One Cone Autonomous: 596, 650
//-- No Run (or modded for Bullet): 845
//-- 60s Autonomous: don't bother, it's pretty busted dude
//- Driver Control: 1119

// For fixes, consult the text file I probably sent you cause I wanted to be able to tell you exact line numbers.

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

int leftError, rightError, driveTarget, driveMax = 127;
float leftResult, rightResult, kp = 0.42;

int gyroError, gyroTarget;
float gyroResult, gyrokp = 0.42;

// Start of functions

void DriveForwardP() //PID Loop Drive Control
{

	while(abs(SensorValue[rightEncoder]) < driveTarget && abs(SensorValue[leftEncoder]) < driveTarget) //was 400
	{
		leftError = driveTarget - SensorValue[leftEncoder];
		rightError = driveTarget - SensorValue[rightEncoder];

		leftResult = leftError * kp;
		rightResult = rightError * kp;

		if(leftResult > driveMax) leftResult = driveMax;
		else if(leftResult < driveMax*-1) leftResult = driveMax*-1;

		if(rightResult > driveMax) rightResult = driveMax;
		else if(rightResult < driveMax*-1) rightResult = driveMax*-1;

		motor[baseLeft] = leftResult;
		motor[baseRight] = rightResult;

		wait1Msec(20);
	}

}

void DriveBackwardP()
{

	while((SensorValue[rightEncoder]) > driveTarget && (SensorValue[leftEncoder]) > driveTarget) //was 400
	{
		leftError = driveTarget - SensorValue[leftEncoder];
		rightError = driveTarget - SensorValue[rightEncoder];

		leftResult = leftError * kp;
		rightResult = rightError * kp;

		if(leftResult > driveMax) leftResult = driveMax;
		else if(leftResult < driveMax*-1) leftResult = driveMax*-1;

		if(rightResult > driveMax) rightResult = driveMax;
		else if(rightResult < driveMax*-1) rightResult = driveMax*-1;

		motor[baseLeft] = leftResult;
		motor[baseRight] = rightResult;

		wait1Msec(20);
	}

}

void TurnPointP()
{
	gyroError = gyroTarget - SensorValue[gyro];
	while(abs(gyroError) > 10) //was 400
	{
		gyroError = gyroTarget - SensorValue[gyro];

		gyroResult = gyroError * gyrokp;

		//if(leftResult > driveMax) leftResult = driveMax;
		//else if(leftResult < driveMax*-1) leftResult = driveMax*-1;

		if(gyroResult > driveMax) gyroResult = driveMax;
		else if(gyroResult < driveMax*-1) gyroResult = driveMax*-1;

		motor[baseLeft] = gyroResult;
		motor[baseRight] = (gyroResult * -1);

		wait1Msec(20);
	}

}

void Bepis()
{
	playTone(783.99,12.5); //g
	playTone(659.25,12.5); //e
	playTone(523.25,25); //c
	playTone(523.25,25); //c
	playTone(523.25,12.5); //c
	playTone(587.33,12.5); //d
	playTone(659.25,12.5); //e
	playTone(698.46,12.5); //f
	playTone(783.99,25); //g
	playTone(783.99,25); //g
	playTone(783.99,25); //g
	playTone(659.25,50); //e
}

void EncoderReset()
{
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

void LiftUp()
{
	motor[liftLeftUp] = 127;
	motor[liftLeftDown] = 127;
	motor[liftRightUp] = 127;
	motor[liftRightDown] = 127;
}

void LiftDown()
{
	motor[liftLeftUp] = -127;
	motor[liftLeftDown] = -127;
	motor[liftRightUp] = -127;
	motor[liftRightDown] = -127;
}

void LiftDownGentle()
{
	motor[liftLeftUp] = -20;
	motor[liftLeftDown] = -20;
	motor[liftRightUp] = -20;
	motor[liftRightDown] = -20;
}

void LiftHold()
{
	motor[liftLeftUp] = 45;
	motor[liftLeftDown] = 45;
	motor[liftRightUp] = 45;
	motor[liftRightDown] = 45;
}

void LiftStop()
{
	motor[liftLeftUp] = 0;
	motor[liftLeftDown] = 0;
	motor[liftRightUp] = 0;
	motor[liftLeftDown] = 0;
}

void DriveForward()
{
	motor[baseLeft] = 127;
	motor[baseRight] = 107;
}

void DriveBackward()
{
	motor[baseLeft] = -127;
	motor[baseRight] = -107;
}

void DriveForwardSlow()
{
	motor[baseLeft] = 127/2;
	motor[baseRight] = 107/2;
}

void DriveBackwardSlow()
{
	motor[baseLeft] = -127/2;
	motor[baseRight] = -107/2;
}

void DriveStop()
{
	motor[baseLeft] = 0;
	motor[baseRight] = 0;
}

void TurnPointLeft()
{
	motor[baseLeft] = -127;
	motor[baseRight] = 127;
}

void TurnPointRight()
{
	motor[baseLeft] = 127;
	motor[baseRight] = -127;
}

void TurnPointLeftSlow()
{
	motor[baseLeft] = -40;
	motor[baseRight] = 40;
}

void TurnPointRightSlow()
{
	motor[baseLeft] = 40;
	motor[baseRight] = -40;
}

void TurnSwingRight()
{
	motor[baseLeft] = 127;
	motor[baseRight] = 0;
}

void TurnSwingLeft()
{
	motor[baseLeft] = 0;
	motor[baseRight] = 127;
}

void MGUp()
{
	motor[mgRight] = 127;
	motor[mgLeft] = 127;
}

void MGDown()
{
	motor[mgRight] = -127;
	motor[mgLeft] = -127;
}

void MGStop()
{
	motor[mgRight] = 0;
	motor[mgLeft] = 0;
}

void LockClose()
{
	motor[lock] = 127;
}

void LockCloseSlow()
{
	motor[lock] = 127/3;
}

void LockOpen()
{
	motor[lock] = -127;
}

void LockStop()
{
	motor[lock] = 0;
}

void LockCheck()
{
	LockClose();
	wait1Msec(500);
	LockStop();
}

void ClawCloseGentle()
{
	motor[claw] = -60;
}

void ClawOpen()
{
	motor[claw] = 127;
}

void ClawOpenHold()
{
	motor[claw] = 60;
}

void ClawClose()
{
	motor[claw] = -127;
}

void ClawStop()
{
	motor[claw] = 0;
}

void BaseReset()
{
	SensorValue(rightEncoder) = 0;
	SensorValue(leftEncoder) = 0;
}

void sensorInit() // The function for initalizing the gyroscope, includes all the waits and etc.
{
	//Gyroscope in analog port 1
	SensorType[Gyro] = sensorNone;
	wait1Msec(250);
	SensorType[Gyro] = sensorGyro;
	wait1Msec(2550);
	playTone(440,25);
}

int autonSelect = 1; //Default Autonomous

void pre_auton()
{

	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	int countMin = 0;
	int countMax = 6;
	int counter = countMin;
	string str[7] = {"GyroInit","BlueL2C","BlueR1C","RedL1C","RedR2C","NoRun","60S"}; //Program Names
	bLCDBacklight = true;
	bStopTasksBetweenModes = true;
	bDisplayCompetitionStatusOnLcd = false;

	while(bIfiRobotDisabled == true)
	{

		if(nLCDButtons == 1)
		{
			if(counter == countMin)
			{
				counter = countMax;
			}

			else
			{
				counter--;
			}

			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else if(nLCDButtons == 4)
		{
			if(counter == countMax)
			{
				counter = countMin;
			}

			else
			{
				counter++;
			}

			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else if(nLCDButtons == 2)
		{
			clearLCDLine(0);
			clearLCDLine(1);
			if(counter != countMin) autonSelect = counter;
			else sensorInit();
			wait1Msec(250);
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"Selected!");
			wait1Msec(400);
			clearLCDLine(0);
			clearLCDLine(1);
			wait1Msec(250);
		}

		else
		{
			displayLCDCenteredString(0,str[counter]);
			displayLCDCenteredString(1,"<    Select    >");
		}

	}

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{

	int ArmLock = 750; //Time Value
	int ArmUnlock = 2000; //Potent Value

	int DriveSpeed = 127; //Drive Speed
	int TurnSpeed = 50;

	switch(autonSelect)
	{

	case 1: //Blue Left

		//---------------------------------TALLGOAL

		ClawClose();
		wait1Msec(500);
		ClawStop();

		while(SensorValue[ArmPotentL] < 800) //CHECK HEIGHT
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		LockStop();

		BaseReset();

		driveTarget = 510; //Goes forward to put first cone on pole
		driveMax = DriveSpeed; //CHECK DISTANCE, was 580
		DriveForwardP();
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > ArmUnlock)
		{
			LockOpen();
		}
		LockStop();

		LiftDownGentle();
		wait1Msec(150);
		LiftStop();

		wait1Msec(500);

		ClawOpen();
		wait1Msec(500); //This is to open the claw.
		DriveStop(); //TEST THIS, WAS AT 1000

		BaseReset();

		ClawStop();
		driveTarget = -350; //Backs up from first attempt.
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = TurnSpeed; //Turns towards cone, first attempt. NOT SPEEDING UP TURN
		gyroTarget = -800; //90 Degree turn, compensating. CHECK FOR OVERTURNING
		TurnPointP();
		DriveStop();

		BaseReset();

		ClawOpenHold(); //Might be several beans too much. JK WHOO
		driveTarget = 415;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		wait1Msec(300);

		ClawCloseGentle();
		wait1Msec(500);
		ClawStop();

		while(SensorValue[ArmPotentL] < 1100) //Grabs second cone.
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		//LockCloseSlow(); //TEST FOR BURNOUT

		BaseReset();

		driveTarget = -540; //Backs up from grabbing second cone. TEST BACKUP
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();
		LockCheck(); //TEST TO SEE IF THIS STOPS

		driveMax = TurnSpeed; //Turns to face pole for second cone.
		gyroTarget = -10; //TEST VALUE FOR TURN, CHECK FOR UNDERTURNING
		TurnPointP();
		DriveStop();

		wait1Msec(250); //

		BaseReset();

		driveTarget = 195; //Approaches pole for second cone.
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > ArmLock) //Latch disengages for second cone.
		{
			LockOpen();
		}
		LockStop();

		LiftDownGentle();
		wait1Msec(150);
		LiftStop();

		wait1Msec(500);

		ClawOpen(); //Claw opens for second cone.
		wait1Msec(500);
		ClawStop();
		DriveStop();

		BaseReset();

		driveTarget = -270; //Backs up from second cone.
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		ClawClose();
		wait1Msec(200);
		ClawStop();

		LiftStop();
		ClawStop();
		DriveStop();
		LockStop();

		wait1Msec(true);

		break;

	case 2: //Blue Right

		//---------------------------------TALLGOAL

		ClawClose();
		wait1Msec(500);
		ClawStop();

		while(SensorValue[ArmPotentL] < 800) //CHECK HEIGHT
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		LockStop();

		BaseReset();

		driveTarget = 510; //Goes forward to put first cone on pole
		driveMax = DriveSpeed; //CHECK DISTANCE, was 580
		DriveForwardP();
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > ArmUnlock)
		{
			LockOpen();
		}
		LockStop();

		LiftDownGentle();
		wait1Msec(150);
		LiftStop();

		wait1Msec(500);

		ClawOpen();
		wait1Msec(500); //This is to open the claw.
		DriveStop(); //TEST THIS, WAS AT 1000

		BaseReset();

		ClawStop();
		driveTarget = -350; //Backs up from first attempt.
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		wait1Msec(true);

		break;

	case 3: //Red Left

		//---------------------------------TALLGOAL

		ClawClose();
		wait1Msec(500);
		ClawStop();

		while(SensorValue[ArmPotentL] < 800) //CHECK HEIGHT
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		LockStop();

		BaseReset();

		driveTarget = 510; //Goes forward to put first cone on pole
		driveMax = DriveSpeed; //CHECK DISTANCE, was 580
		DriveForwardP();
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > ArmUnlock)
		{
			LockOpen();
		}
		LockStop();

		LiftDownGentle();
		wait1Msec(150);
		LiftStop();

		wait1Msec(500);

		ClawOpen();
		wait1Msec(500); //This is to open the claw.
		DriveStop(); //TEST THIS, WAS AT 1000

		BaseReset();

		ClawStop();
		driveTarget = -350; //Backs up from first attempt.
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		wait1Msec(true);

		break;

	case 4: //Red Right

		//---------------------------------TALLGOAL

		ClawClose();
		wait1Msec(500);
		ClawStop();

		while(SensorValue[ArmPotentL] < 800) //CHECK HEIGHT
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		LockStop();

		BaseReset();

		driveTarget = 510; //Goes forward to put first cone on pole
		driveMax = DriveSpeed; //CHECK DISTANCE, was 580
		DriveForwardP();
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > ArmUnlock)
		{
			LockOpen();
		}
		LockStop();

		LiftDownGentle();
		wait1Msec(150);
		LiftStop();

		wait1Msec(500);

		ClawOpen();
		wait1Msec(500); //This is to open the claw.
		DriveStop(); //TEST THIS, WAS AT 1000

		BaseReset();

		ClawStop();
		driveTarget = -350; //Backs up from first attempt.
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		driveMax = TurnSpeed; //Turns towards cone, first attempt. NOT SPEEDING UP TURN
		gyroTarget = 800; //90 Degree turn, compensating. CHECK FOR OVERTURNING
		TurnPointP();
		DriveStop();

		//STOPPED WORKING HERE

		BaseReset();

		ClawOpenHold(); //Might be several beans too much. JK WHOO
		driveTarget = 415;
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		wait1Msec(300);

		ClawCloseGentle();
		wait1Msec(500);
		ClawStop();

		while(SensorValue[ArmPotentL] < 1100) //Grabs second cone.
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		//LockCloseSlow(); //TEST FOR BURNOUT

		BaseReset();

		driveTarget = -540; //Backs up from grabbing second cone. TEST BACKUP
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();
		LockCheck(); //TEST TO SEE IF THIS STOPS

		driveMax = TurnSpeed; //Turns to face pole for second cone.
		gyroTarget = -10; //TEST VALUE FOR TURN, CHECK FOR UNDERTURNING
		TurnPointP();
		DriveStop();

		wait1Msec(250); //

		BaseReset();

		driveTarget = 195; //Approaches pole for second cone.
		driveMax = DriveSpeed;
		DriveForwardP();
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > ArmLock) //Latch disengages for second cone.
		{
			LockOpen();
		}
		LockStop();

		LiftDownGentle();
		wait1Msec(150);
		LiftStop();

		wait1Msec(500);

		ClawOpen(); //Claw opens for second cone.
		wait1Msec(500);
		ClawStop();
		DriveStop();

		BaseReset();

		driveTarget = -270; //Backs up from second cone.
		driveMax = DriveSpeed;
		DriveBackwardP();
		DriveStop();

		ClawClose();
		wait1Msec(200);
		ClawStop();

		LiftStop();
		ClawStop();
		DriveStop();
		LockStop();

		wait1Msec(true);

		break;

	case 5: //No Run

		// FOR BULLET AUTO, JUST UNCOMMENT THE STUFF BELOW
		//DriveBackward();
		//wait1Msec(10000);
		//DriveStop();

		wait1Msec(true);

		break;

	case 6: //60s Autonomous (THIS IS BROKEN AS HECK)

		//---------------------------------TALLGOAL

		ClawClose();

		wait1Msec(500);
		ClawStop();

		while(SensorValue[ArmPotentL] < 800) //TEST THIS THINGY
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		LockStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 540 && abs(SensorValue[leftEncoder]) < 540) //was 515
		{
			DriveForwardSlow();
		}
		DriveStop();

		wait1Msec(1000); //Reduce?

		while(SensorValue[LockPotent] > 1800) // L: 2562 U: 1420
		{
			LockOpen();
		}
		LockStop();

		LiftDownGentle();
		wait1Msec(150);
		LiftStop();

		ClawOpen();
		wait1Msec(1000); //Reduce?
		ClawStop();
		DriveStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 200 && abs(SensorValue[leftEncoder]) < 200) //Was 165
		{
			DriveBackwardSlow();
		}
		DriveStop();

		wait1Msec(500);

		while(abs(SensorValue[Gyro]) < 830) //check turn, was 790
		{
			TurnPointLeftSlow();
		}
		DriveStop();

		LiftDown();
		wait1Msec(100);
		LiftStop();
		ClawOpen();
		wait1Msec(350);
		ClawStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 350 && abs(SensorValue[leftEncoder]) < 350) //was 370
		{
			DriveForwardSlow();
			ClawOpenHold();
		}
		DriveStop();

		LiftDown();
		ClawClose();
		wait1Msec(350);
		LiftStop();
		ClawStop();

		wait1Msec(50);

		while(SensorValue[ArmPotentL] < 1100) //TEST THIS THINGY
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		LockStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 480 && abs(SensorValue[leftEncoder]) < 480) //Was 435, aligns with pole
		{
			DriveBackwardSlow();
		}
		DriveStop();

		while(abs(SensorValue[Gyro]) > 25) //Was 0, CHECK FOR OVERROTATING
		{
			TurnPointRightSlow();
		}
		DriveStop();

		wait1Msec(500); // lined up with cone on ground, goin for a slam dunk

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 200 && abs(SensorValue[leftEncoder]) < 200) //was 230
		{
			DriveForwardSlow();
		}
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > 2100)
		{
			LockOpen();
		}
		LockStop();

		wait1Msec(500);

		ClawOpen();
		wait1Msec(500);
		ClawStop();
		DriveStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 200 && abs(SensorValue[leftEncoder]) < 200) //Was 165
		{
			DriveBackwardSlow();
		}
		DriveStop();

		wait1Msec(500);

		//Going for 3rd cone

		while(abs(SensorValue[Gyro]) < 830) //check turn, was 790
		{
			TurnPointLeftSlow();
		}
		DriveStop();

		LiftDown();
		wait1Msec(100);
		LiftStop();
		ClawOpen();
		wait1Msec(350);
		ClawStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 500 && abs(SensorValue[leftEncoder]) < 500)
		{
			DriveForwardSlow();
			ClawOpenHold();
		}
		DriveStop();

		LiftDown();
		ClawClose();
		wait1Msec(350);
		LiftStop();
		ClawStop();

		wait1Msec(50);

		while(SensorValue[ArmPotentL] < 1100) //TEST THIS THINGY
		{
			LiftUp();
		}
		LiftStop();
		LockClose();
		wait1Msec(ArmLock);
		LockStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 575 && abs(SensorValue[leftEncoder]) < 750) //Was 435, aligns with pole
		{
			DriveBackwardSlow();
		}
		DriveStop();

		while(abs(SensorValue[Gyro]) > 25) //Was 0, CHECK FOR OVERROTATING
		{
			TurnPointRightSlow();
		}
		DriveStop();

		wait1Msec(500); // lined up with cone on ground, goin for a slam dunk

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 200 && abs(SensorValue[leftEncoder]) < 200) //was 230
		{
			DriveForwardSlow();
		}
		DriveStop();

		wait1Msec(500);

		while(SensorValue[LockPotent] > 2100)
		{
			LockOpen();
		}
		LockStop();

		wait1Msec(500);

		ClawOpen();
		wait1Msec(500);
		ClawStop();
		DriveStop();

		BaseReset();

		while(abs(SensorValue[rightEncoder]) < 200 && abs(SensorValue[leftEncoder]) < 200) //Was 165
		{
			DriveBackwardSlow();
		}
		DriveStop();

		wait1Msec(500);

		wait1Msec(true);

		break;

	}

}

task Horn()
{
	while (1==1)
	{
		if(vexRT[Btn8U] == 1)
		{
			Bepis();
		}
		wait1Msec(20);
	}
}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	startTask(Horn);
	while(1==1)
	{

		// LIFT CONTROL
		motor[liftLeftUp] = (vexRT[Btn6U] * 127) - (vexRT[Btn6D] * 127);
		motor[liftLeftDown] = (vexRT[Btn6U] * 127) - (vexRT[Btn6D] * 127);
		motor[liftRightUp] = (vexRT[Btn6U] * 127) - (vexRT[Btn6D] * 127);
		motor[liftRightDown] = (vexRT[Btn6U] * 127) - (vexRT[Btn6D] * 127);

		//MG CONTROL
		motor[mgRight] = (vexRT[Btn5U] * 127) - (vexRT[Btn5D] * 127);
		motor[mgLeft] = (vexRT[Btn5U] * 127) - (vexRT[Btn5D] * 127);

		//LOCK CONTROL
		motor[lock] = (vexRT[Btn7L] * 127/2) - (vexRT[Btn7D] * 127/2);

		//CLAW CONTROL
		motor[claw] = (vexRT[Btn8D] * 127) - (vexRT[Btn8R] * 127);

		//DRIVE CONTROL
		motor[baseLeft] = vexRT[Ch3] + vexRT[Ch1];
		motor[baseRight] = vexRT[Ch3] - vexRT[Ch1];

		//BEPIS

		wait1Msec(20);

	}

}
